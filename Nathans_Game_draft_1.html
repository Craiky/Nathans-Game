 <!DOCTYPE html>
<html>
<head>
    <title>Nathan's First JavaScript Game</title>
    <style>
    </style>
</head>
<body>
    <h1>Nathan's First JavaScript Game</h1>
    <p>This is my first time creating a game using JavaScript</p>
    <h2>*Insert Creative Game Title Here*</h2>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</body>
<script>
/* Things to add to game
-tutorial level
-menu
-more levels
-level select
-sprites
*/
    
let canvas;
    
let canvasContext; 
    
let gravity = 9.8; // pixels/s
    
let interval;
    
let frameRate = 1000/60

let showingWinScreen = false;
    
let enemyShootingInterval;
    
let hideDismiss = true;
    
let currentLevel;
    
let showingMenu = true
    
let heart = new Image(100, 200)
heart.src = 'heart.png'
    
let spikeImage = new Image (100, 200) 
spikeImage.src = 'spike.png'
    
    
//character:{x,y,health,dir}
//exit:{x,y}
//platforms:[{x,y,width,height,color}...]
//enemies:[{x,y,dir,leftX,leftY,rightX,rightY}...]
//turrets:[{}...]
//spikes:[{}...]

let levels = [
                {
                    level: 1,
                    character:{x:50, y:490, health:3, dir:"right"}, 
                    exit:{x:270, y:245}, 
                    platforms:[{x:-10, y:500, width:300, height:50, color:"black"}, {x:400, y:500, width:420, height:50, color:"black"}, {x:650, y:420, width:169, height:80, color:"black"}, {x:500, y:365, width:100, height:20, color:"black"}, {x:270, y:315, width:150, height:20, color:"black"}], 
                    enemies:[], 
                    turrets:[], 
                    spikes:[{startX: 292.5, endX: 393.5, startY: 525, endY: 0, direction: 'up'}]
                },
                {
                    level: 2,
                    character:{x:100, y:465, health:3, dir:"right"}, 
                    exit:{x:20, y:240}, 
                    platforms:[{x:40, y:475, width:115, height:75, color:"black"}, {x:250, y:475, width:135, height:75, color:"black"}, {x:495, y:475, width:135, height:75, color:"black"}, {x:680, y:475, width:60, height:75, color:"black"}, {x:770, y:415, width:40, height:20, color:"black"}, {x:625, y:345, width:75, height:20, color:"black"}, {x:475, y:320, width:100, height:20, color:"black"}, {x:305, y:305, width:100, height:20, color:"black"}, {x:170, y:315, width:50, height:20, color:"black"}, {x:20, y:310, width:75, height:20, color:"black"}], 
                    enemies:[], 
                    turrets:[], 
                    spikes:[{startX: -5, endX: 40, startY: 525, endY: 0, direction: 'up'}, {startX: 157.5, endX: 235, startY: 525, endY: 0, direction: 'up'}, {startX: 387.5, endX: 485, startY: 525, endY: 0, direction: 'up'}, {startX: 632.5, endX: 670, startY: 525, endY: 0, direction: 'up'}, {startX: 740, endX: 815, startY: 525, endY: 0, direction: 'up'}]
                },
                {
                    level: 3,
                    character:{x:10, y:540, health:3, dir:"right"}, 
                    exit:{x:755, y:120}, 
                    platforms:[{x:470, y:450, width:400, height:20, color:"black"}, {x:450, y:450, width:20, height:200, color:"black"}, {x:250, y:350, width:200, height:20, color:"black"}, {x:0, y:300, width:250, height:20, color:"black"}, {x:0, y:100, width:20, height:200, color:"black"}, {x:325, y:240, width:100, height:20, color:"black"}, {x:450, y:190, width:350, height:20, color:"black"}], 
                    enemies:[{x:700, y:155, dir:"left-right", leftX:200, leftY:100, rightX:50, rightY:100}, {x:700, y:415, dir:"left-right", leftX:300, leftY:100, rightX:100, rightY:100}, {x:45, y:265, dir:"right", leftX:0, leftY:0, rightX:300, rightY:100}], 
                    turrets:[], 
                    spikes:[{startX: 425, endX: 0, startY: 485, endY: 550, direction: 'left'}, {startX: 45, endX: 0, startY: 150, endY: 300, direction: 'right'}]
                },
                {
                    level: 4,
                    character:{x:20, y:540, health:3, dir:"right"}, 
                    exit:{x:565, y:480}, 
                    platforms:[{x: 165, y:270, width:20, height:325}, {x:290, y:250, width:60, height:20}, {x:115, y:250, width:40, height:20}, {x:350, y:0, width:20, height:470}, {x:545, y:195, width:20, height:500}, {x:485, y:175, width:150, height:20}, {x:780, y:0, width:20, height:580}, {x:655, y:315, width:125, height:20}, {x:565, y:455, width:125, height:20},{x:-10, y:450, width:50, height:20}, {x:115, y:350, width:50, height:20}, {x:-10, y:250, width:50, height:20}, {x:370, y:450, width:50, height:20}, {x:495, y:350, width:50, height:20}, {x:370, y:250, width:50, height:20}], 
                    enemies:[{x:335, y:215, dir:'left', leftX:350, leftY:125, rightX:0, rightY:0}, {x:530, y:515, dir:'left', leftX:375, leftY:150, rightX:0, rightY:0}], 
                    turrets:[], 
                    spikes:[{startX: 520, endX: 590, startY: 150, endY: 0, direction: 'up'}, {startX: 655, endX: 670, startY: 290, endY: 0, direction: 'up'}, {startX: 655, endX: 670, startY: 430, endY: 0, direction: 'up'}]
                }
             ]
                    
let platforms = []
let enemies = []
let turrets = []
let spikes = []
    
let exit = {
    x:0,
    y:0,
    width:50,
    height:70,
    color:"red"
}

let character1 = {
    xPos: 10,
    yPos: 540,
    xVel: 0,
    yVel: 0,
    jumping: false,
    health: 3,
    dead: false,
    justTookDamage: false,
    dir: "right",
    bullets: [],
    shooting: false,
    jumps: 0,
    drawCharacter () {
        createCircle(character1.xPos, character1.yPos, 10, 'black');  
    },
    shoot (){
        if(character1.dir == "left" && character1.shooting){
            character1.bullets.push(new bullet(character1.xPos - 15, character1.yPos, 5, 180*(Math.PI/180), 'player'))
        }else if(character1.dir == "right" && character1.shooting){
            character1.bullets.push(new bullet(character1.xPos + 10, character1.yPos, 5, 0, 'player'))
        }
    },
    shootBullets () {
        for(let i = 0; i < character1.bullets.length; i++){
            character1.bullets[i].moving()
            if(character1.bullets[i].bulletMoving == false){
                character1.bullets.splice(i,1)
        }
    }
    },
    reset(xPos, yPos) {
        this.xPos = xPos;
        this.yPos = yPos;
        this.xVel = 0;
        this.yVel = 0;
        this.health = 3;
        character1.bullets = []
    },
    healthBar () {
        switch (character1.health) {
        case 3:
            createText('Health Bar', 30, 15, '15px', 'Arial', 'red')
            createRect(5, 22.5, 125, 37.5, 'white')
            for (let i = 10; i < 91; i += 40) {
                canvasContext.drawImage(heart, i, 25, 35, 35)
            }
            break;
        case 2:
            createText('Health Bar', 30, 15, '15px', 'Arial', 'red')
            createRect(5, 22.5, 125, 37.5, 'white')
            for (let i = 10; i < 51; i += 40) {
                canvasContext.drawImage(heart, i, 25, 35, 35)
            }
            break;
        case 1:
            createText('Health Bar', 30, 15, '15px', 'Arial', 'red')
            createRect(5, 22.5, 125, 37.5, 'white')
            canvasContext.drawImage(heart, 10, 25, 35, 35)  
            break;
        case 0:
            character1.dead = true;
            break;
        }
    }
};
   
    
    
    
    
    
    
class enemy {
    constructor(xPos, yPos, direction, leftX = 0, leftY = 0, rightX = 0, rightY = 0) {
        this.xPos = xPos
        this.yPos = yPos
        this.direction = direction
        this.height = 35
        this.width = 15
        this.shooting = false
        this.bullets = []
        this.health = 5
        this.justTookDamage = false
        this.dead = false
        this.leftX = leftX
        this.leftY = leftY
        this.rightX = rightX
        this.rightY = rightY
        // shooting site
    }
    drawEnemy () {
        if (this.dead === false) {
            createRect(this.xPos, this.yPos, this.width, this.height, 'black')
        }
    }
    enemyAI () {
        if (this.dead === false) {
            if (this.direction === 'left') {
                if (character1.xPos > this.xPos - this.leftX && character1.xPos < this.xPos && character1.yPos > this.yPos - this.leftY && character1.yPos < this.yPos + this.height) {
                    this.bullets.push(new bullet(this.xPos - 10, this.yPos + 17.5, -5, Math.atan((character1.yPos-(this.yPos + 17.5))/(character1.xPos-(this.xPos - 10))), 'enemy'))
                }
            }
            if (this.direction === 'right') {
                if (character1.xPos > this.xPos && character1.xPos < this.xPos + this.rightX && character1.yPos > this.yPos - this.rightY && character1.yPos < this.yPos + this.height) {
                    this.bullets.push(new bullet(this.xPos + 20, this.yPos + 17.5, 5, Math.atan((character1.yPos-(this.yPos + 17.5))/(character1.xPos-(this.xPos - 10))), 'enemy'))
                }            
            }
            if (this.direction === 'left-right') {
                if (character1.xPos > this.xPos && character1.xPos < this.xPos + this.rightX && character1.yPos > this.yPos - this.rightY && character1.yPos < this.yPos + this.height) {
                    this.bullets.push(new bullet(this.xPos + 20, this.yPos + 17.5, 5, Math.atan((character1.yPos-(this.yPos + 17.5))/(character1.xPos-(this.xPos - 10))), 'enemy'))
                }
                if (character1.xPos > this.xPos - this.leftX && character1.xPos < this.xPos && character1.yPos > this.yPos - this.leftY && character1.yPos < this.yPos + this.height) {
                    this.bullets.push(new bullet(this.xPos - 10, this.yPos + 17.5, -5, Math.atan((character1.yPos-(this.yPos + 17.5))/(character1.xPos-(this.xPos - 10))), 'enemy'))
                }
            }
        }
    }
    
    shootBullets () {
        for(let i = 0; i < this.bullets.length; i++){
        this.bullets[i].moving()
        
        if(this.bullets[i].bulletMoving == false){
            this.bullets.splice(i,1)
            }
        }
    }
    reset () {
        this.dead = false
        this.health = 5
        this.bullets = []
    }
    healthBar () {
        switch (this.health) { 
        case 4:  
            createText('Enemy Health', this.xPos - 24, this.yPos - 22.5, '10px', 'Arial', 'red') 
            //createRect(this.xPos - 35, this.yPos - 17, 83.5, 19, 'white') 
            for (let i = 0; i < 49; i += 16) { 
                canvasContext.drawImage(heart, this.xPos - 32.5 + i, this.yPos - 15, 15, 15) 
            } 
            break; 
        case 3: 
            createText('Enemy Health', this.xPos - 24, this.yPos - 22.5, '10px', 'Arial', 'red') 
            //createRect(this.xPos - 35, this.yPos - 17, 83.5, 19, 'white') 
            for (let i = 0; i < 33; i += 16) { 
                canvasContext.drawImage(heart, this.xPos - 32.5 + i, this.yPos - 15, 15, 15) 
            } 
            break; 
        case 2: 
            createText('Enemy Health', this.xPos - 24, this.yPos - 22.5, '10px', 'Arial', 'red') 
            //createRect(this.xPos - 35, this.yPos - 17, 83.5, 19, 'white') 
            for (let i = 0; i < 17; i += 16) { 
                canvasContext.drawImage(heart, this.xPos - 32.5 + i, this.yPos - 15, 15, 15) 
            } 
            break; 
        case 1:  
            createText('Enemy Health', this.xPos - 24, this.yPos - 22.5, '10px', 'Arial', 'red') 
            //createRect(this.xPos - 35, this.yPos - 17, 83.5, 19, 'white') 
            canvasContext.drawImage(heart, this.xPos - 32.5, this.yPos - 15, 15, 15)
            break;
        case 0:  
            this.dead = true; 
            break; 
        } 
    }
}
    
    
class turret {
    constructor(xPos, yPos, direction, leftX = 0, leftYDown = 0, leftYUp = 0, rightX = 0, rightYDown = 0, rightYUp = 0) {
        this.xPos = xPos;
        this.yPos = yPos;
        this.direction = direction;
        this.height = 30;
        this.width = 15;
        this.shooting = false;
        this.bullets = [];
        this.leftX = leftX
        this.leftYUp = leftYUp
        this.leftYDown = leftYDown
        this.rightX = rightX;
        this.rightYUp = rightYUp
        this.rightYDown = rightYDown
    }
    turretAI () {
        if (this.direction === 'left') {
            if (character1.xPos > this.xPos - this.leftX && character1.xPos < this.xPos && character1.yPos < this.yPos + this.leftYDown && character1.yPos > this.yPos - this.leftYUp) {
                this.bullets.push(new bullet(this.xPos - 10, this.yPos, -5, Math.atan((character1.yPos-(this.yPos))/(character1.xPos-(this.xPos - 10))), 'enemy'))
            }
        }
        if (this.direction === 'right') {
            if (character1.xPos > this.xPos && character1.xPos < this.xPos + this.rightX && character1.yPos < this.yPos + this.rightYDown && character1.yPos > this.yPos - this.rightYUp) {
                this.bullets.push(new bullet(this.xPos + 10, this.yPos, 5, (Math.PI/2)-Math.atan((character1.xPos-(this.xPos+10))/(character1.yPos-(this.yPos))), 'enemy'))
            }
        }
    }
    drawTurret () {
        if (this.direction === 'left') {
            canvasContext.fillStyle = 'black';
            canvasContext.beginPath();
            canvasContext.arc(this.xPos, this.yPos, this.width, 1.5708, 4.71239, false)
            canvasContext.fill();
        }
        if (this.direction === 'right') {
            canvasContext.fillStyle = 'black';
            canvasContext.beginPath();
            canvasContext.arc(this.xPos, this.yPos, this.width, 1.5708, 4.71239, true)
            canvasContext.fill();
        }
    }
    shootBullets() {
            for(let i = 0; i < this.bullets.length; i++){
                this.bullets[i].moving()
                if(this.bullets[i].bulletMoving == false){
                    this.bullets.splice(i,1)
            }
        }
    }
    reset () {
        this.bullets = []
    }
}
    
class bullet{
    constructor(x, y, vel, angle, type){
    this.xPos = x
    this.yPos = y
    this.angle = angle
    this.xVel = Math.cos(angle)*vel
    this.yVel = Math.sin(angle)*vel
    this.bulletMoving = true;
    this.bulletType = type;
    }   
    moving(){
        if (this.bulletType === 'enemy'){
            canvasContext.save()
            canvasContext.translate(this.xPos, this.yPos);
            canvasContext.rotate(this.angle)
            createRect(0, 0, 10, 5, 'red')
            canvasContext.restore()
        
            if (this.bulletMoving) {
            
                this.xPos += this.xVel;
                this.yPos += this.yVel;
            }
            setTimeout(() => this.bulletMoving = false, 1750)
            if (this.xPos < 0) {
                this.bulletMoving = false;
            }
            if(this.xPos > canvas.width){
                this.bulletMoving = false;
            }
        
            if (character1.xPos > this.xPos - 5 && character1.xPos < this.xPos + 15 && character1.yPos > this.yPos - 10 && character1.yPos < this.yPos + 15 &&     character1.justTookDamage === false) {
                character1.justTookDamage = true;
                setTimeout(() => {character1.justTookDamage = false}, 500)
                character1.health --;
                this.bulletMoving = false;
            }
            // platform collision
            for (let i = 0; i < platforms.length; i ++) {
                // left side
                if (this.xPos > platforms[i].xPos - 10 && this.xPos < platforms[i].xPos && this.yPos > platforms[i].yPos && this.yPos < platforms[i].yPlusHeight) {
                    this.bulletMoving = false;
                }
                // right side
                if (this.xPos > platforms[i].xPlusWidth && this.xPos < platforms[i].xPlusWidth + 10 && this.yPos > platforms[i].yPos && this.yPos < platforms[i].yPlusHeight) {
                    this.bulletMoving = false;
                }
                // top side
                if (this.xPos > platforms[i].xPos && this.xPos < platforms[i].xPlusWidth && this.yPos > platforms[i].yPos - 10 && this.yPos < platforms[i].yPos) {
                    this.bulletMoving = false;
                }
                // bottom side
                if (this.xPos > platforms[i].xPos && this.xPos < platforms[i].xPlusWidth && this.yPos > platforms[i].yPlusHeight && this.yPos < platforms[i].yPlusHeight + 10) {
                    this.bulletMoving = false;
                }
            }
        }
        if (this.bulletType === 'player') {
            createRect(this.xPos, this.yPos, 10, 5, 'green')
        
            if (this.bulletMoving) {
            
                this.xPos += this.xVel;
                this.yPos += this.yVel;
            }
            setTimeout(() => this.bulletMoving = false, 1000)
            if (this.xPos < 0) {
                this.bulletMoving = false;
            }
            if(this.xPos > canvas.width){
                this.bulletMoving = false;
            }
            for (let i = 0; i < enemies.length; i ++) {
                    if (this.xPos > enemies[i].xPos && this.xPos < enemies[i].xPos + enemies[i].width && this.yPos > enemies[i].yPos && this.yPos < enemies[i].yPos + enemies[i].height && enemies[i].justTookDamage === false) {
                        enemies[i].justTookDamage = true;
                        setTimeout(() => enemies[i].justTookDamage = false, 1000)
                        enemies[i].health --;
                    }
            }
            // platform collision
            for (let i = 0; i < platforms.length; i ++) {
                // left side
                if (this.xPos > platforms[i].xPos - 10 && this.xPos < platforms[i].xPos && this.yPos > platforms[i].yPos && this.yPos < platforms[i].yPlusHeight) {
                    this.bulletMoving = false;
                }
                // right side
                if (this.xPos > platforms[i].xPlusWidth && this.xPos < platforms[i].xPlusWidth + 10 && this.yPos > platforms[i].yPos && this.yPos < platforms[i].yPlusHeight) {
                    this.bulletMoving = false;
                }
                // top side
                if (this.xPos > platforms[i].xPos && this.xPos < platforms[i].xPlusWidth && this.yPos > platforms[i].yPos - 10 && this.yPos < platforms[i].yPos) {
                    this.bulletMoving = false;
                }
                // bottom side
                if (this.xPos > platforms[i].xPos && this.xPos < platforms[i].xPlusWidth && this.yPos > platforms[i].yPlusHeight && this.yPos < platforms[i].yPlusHeight + 10) {
                    this.bulletMoving = false;
                }
            }
        }
    }
}     
    
class platform {
    constructor(x, y, width, height, color = 'black') {
        this.x = x
        this.y = y
        this.width = width
        this.height = height
        this.color = color
        this.yPlusHeight = this.y + this.height
        this.xPlusWidth = this.x + this.width
    }
    drawPlatform() {
        createPlatform(this.x, this.y, this.width, this.height, this.color)
    }
    collision () {
        // top part of the platform
        if (character1.xPos > this.x && character1.xPos < this.x + this.width && character1.yPos < this.y && character1.yPos > this.y - 20) {
            character1.yPos = this.y - 10;
            //character1.jumps = 0
            character1.jumping = false
            character1.yVel = -character1.yVel*0.2; // bounciness
            if(character1.xVel != 50 && character1.xVel != -50){
                character1.xVel *= 0.9 //friction
            }
        }
        // bottom part
        if (character1.xPos > this.x && character1.xPos < this.x + this.width && character1.yPos > this.yPlusHeight && character1.yPos < this.yPlusHeight + 10) {
            character1.yPos = this.yPlusHeight + 10;
            character1.jumping = false;
            character1.yVel = -character1.yVel*0.2; // bounciness
            if(character1.xVel != 50 && character1.xVel != -50){
                character1.xVel *= 0.9 //friction
            }
        }
        // left side
        if (character1.xPos < this.x && character1.xPos > this.x - 10 && character1.yPos < this.yPlusHeight && character1.yPos > this.y) {
            character1.xVel = 0;
            character1.xPos = this.x - 10;
            character1.yVel = -character1.yVel*0.2; // bounciness
        }
        // right side
        if (character1.xPos > this.xPlusWidth && character1.xPos < this.xPlusWidth + 10 && character1.yPos < this.yPlusHeight && character1.yPos > this.y) {
            character1.xVel = 0;
            character1.xPos = this.xPlusWidth + 10;
            character1.yVel = -character1.yVel*0.2; // bounciness
        }
        // left corner
        if (character1.xPos > this.x && character1.xPos < this.x + 20 && character1.yPos < this.yPlusHeight && character1.yPos > this.y) {
            character1.xVel = 0;
            character1.xPos = this.x - 10;
            character1.yVel = -character1.yVel*0.2; // bounciness
        }
        // right corner
        if (character1.xPos > this.xPlusWidth - 20 && character1.xPos < this.xPlusWidth && character1.yPos < this.yPlusHeight && character1.yPos > this.y) {
            character1.xVel = 0;
            character1.xPos = this.xPlusWidth + 10;
            character1.yVel = -character1.yVel*0.2; // bounciness
        }
    }
}
 
class spike {
    constructor (xPos, yPos, orientation) {
        this.xPos = xPos
        this.yPos = yPos
        this.orientation = orientation
        this.width = 15
        this.height = 25
    }
    drawSpikes () {
        if (this.orientation === 'right') {
            canvasContext.save()
            canvasContext.translate(this.xPos, this.yPos)
            canvasContext.rotate(90 * (Math.PI / 180))
            canvasContext.drawImage(spikeImage, 0, 0, this.width, this.height)
            canvasContext.restore();
        } else if (this.orientation === 'left') {
            canvasContext.save()
            canvasContext.translate(this.xPos, this.yPos)
            canvasContext.rotate(270 * (Math.PI / 180))
            canvasContext.drawImage(spikeImage, 0, 0, this.width, this.height)
            canvasContext.restore()
        } else if (this.orientation === 'up') {
            canvasContext.drawImage(spikeImage, this.xPos, this.yPos, this.width, this.height)
        } else if (this.orientation === 'down') {
            canvasContext.save()
            canvasContext.translate(this.xPos, this.yPos)
            canvasContext.rotate(180 * (Math.PI / 180))
            canvasContext.drawImage(spikeImage, 0, 0, this.width, this.height)
            canvasContext.restore()
        }
    }
    collision () {
        if (this.orientation === 'right') {
            // top of spike
            if (character1.xPos > this.xPos - this.height - 10 && character1.xPos < this.xPos && character1.yPos < this.yPos && character1.yPos > this.yPos - 20) {
                character1.yPos = this.yPos - 10;
                //character1.jumps = 0;
                character1.jumping = false
                spikeCollision()
            }
            //right side of spike
            if (character1.xPos > this.xPos && character1.xPos < this.xPos + 10 && character1.yPos < this.yPos + this.width && character1.yPos > this.yPos) {
                character1.xPos = this.xPos + 10;
                character1.xVel = 0;
                spikeCollision()
            }
            // bottom side of spike
            if (character1.xPos > this.xPos - this.height -5 && character1.xPos < this.xPos && character1.yPos < this.yPos + this.width + 10 && character1.yPos > this.yPos + this.width) {
                character1.yPos = this.yPos + this.width +  10;
                 character1.jumping = false
                spikeCollision()
            }
            
        } else if (this.orientation === 'left') {
            // top of spike
            if (character1.xPos > this.xPos && character1.xPos < this.xPos + this.height && character1.yPos < this.yPos - this.width && character1.yPos > this.yPos - this.width - 20) {
                character1.yPos = this.yPos -this.width- 10;
                character1.jumping = false
                spikeCollision()
            }
            //left side of spike
            if (character1.xPos < this.xPos && character1.xPos > this.xPos - 10 && character1.yPos < this.yPos && character1.yPos > this.yPos - this.width) {
                character1.xPos = this.xPos - 10;
                character1.xVel = 0;
                spikeCollision()
            }
            // bottom side of spike
            if (character1.xPos > this.xPos && character1.xPos < this.xPos + this.height && character1.yPos < this.yPos + 10 && character1.yPos > this.yPos) {
                character1.yPos = this.yPos + 10;
                character1.jumping = false
                spikeCollision()
            }
        } else if (this.orientation === 'up') {
            // top of spike
            if (character1.xPos > this.xPos - 10 && character1.xPos < this.xPos + 10 && character1.yPos < this.yPos && character1.yPos > this.yPos - 20) {
                character1.yPos = this.yPos - 10;
                character1.jumping = false
                spikeCollision()
            }
            //left side of spike
            if (character1.xPos < this.xPos && character1.xPos > this.xPos - 10 && character1.yPos > this.yPos && character1.yPos < this.yPos + 25) {
                character1.xPos = this.xPos - 10;
                character1.xVel = 0;
                spikeCollision()
            }
            // ride side of spike
            if (character1.xPos > this.xPos && character1.xPos < this.xPos + this.width + 10 && character1.yPos > this.yPos && character1.yPos < this.yPos + 25) {
                character1.xPos = this.xPos + this.width + 10;
                character1.xVel = 0;
                spikeCollision()
            }
        } else if (this.orientation === 'down') {
            // bottom of spike
            if (character1.xPos > this.xPos - this.width && character1.xPos < this.xPos && character1.yPos < this.yPos + 10 && character1.yPos > this.yPos) {
                character1.yPos = this.yPos + 10;
                character1.jumping = false
                spikeCollision()
            }
            //left side of spike
            if (character1.xPos > this.xPos - this.width - 10 && character1.xPos < this.xPos - this.width && character1.yPos < this.yPos && character1.yPos > this.yPos - this.height) {
                character1.xPos = this.xPos - this.width - 10;
                character1.xVel = 0;
                spikeCollision()
            }
            // ride side of spike
            if (character1.xPos > this.xPos && character1.xPos < this.xPos + 10 && character1.yPos < this.yPos && character1.yPos > this.yPos - this.height) {
                character1.xPos = this.xPos + 10;
                character1.xVel = 0;
                spikeCollision()
            }
        }
    }
}


function spikeCollision () {
        character1.yVel = -character1.yVel*0.2; // bounciness 
        if(character1.xVel != 50 && character1.xVel != -50){
                    character1.xVel *= 0.9 //friction
        }
        if (character1.justTookDamage === false) {
            character1.justTookDamage = true;
            character1.health --;
            setTimeout(() => character1.justTookDamage = false, 1000)
        }
}
    
    
    
    
    
    
    

    
function loadLevel (level){
    
    character1.reset(level.character.x,level.character.y)
    character1.dir = level.character.dir
    
    platforms = []
    enemies = []
    turrets = []
    spikes = []
    
    currentLevel = level.level
    
    exit.x = level.exit.x
    exit.y = level.exit.y
    
    console.log(exit)
    
    for(i=0;i<level.platforms.length;i++){
        platforms.push(new platform(level.platforms[i].x,level.platforms[i].y,level.platforms[i].width,level.platforms[i].height,level.platforms[i].color))
    }
    
    for(i=0;i<level.enemies.length;i++){
        enemies.push(new enemy(level.enemies[i].x,level.enemies[i].y,level.enemies[i].dir,level.enemies[i].leftX,level.enemies[i].leftY,level.enemies[i].rightX,level.enemies[i].rightY))
    }
    
    for(i=0;i<level.turrets.length;i++){
        platforms.push()
    }
    
    for(i=0;i<level.spikes.length;i++){
        if(level.spikes[i].direction == "left" || level.spikes[i].direction == "right"){
            for (let e = level.spikes[i].startY; e < level.spikes[i].endY; e += 15) {
                spikes.push(new spike(level.spikes[i].startX, e, level.spikes[i].direction))
            }
        }
        console.log(level.spikes)
        
        if(level.spikes[i].direction == "up" || level.spikes[i].direction == "up"){
            for (let e = level.spikes[i].startX; e < level.spikes[i].endX; e += 15) {
                spikes.push(new spike(e, level.spikes[i].startY, level.spikes[i].direction))
            }
        }
    }
    
    createRect(0, 0, canvas.width, canvas.height, 'white')
    createText("level "+level.level, 400, 300, '50px', 'Arial', 'black')
    createText('Press E to Begin', 400, 400, '25px', 'Arial', 'Black')
    hideDismiss = false;
}
  

    
    
function drawLevel(){ 
    //clearing previous frame
    canvasContext.clearRect(0,0,canvas.width,canvas.height)
    
    /*if (showingWinScreen) {
        createRect(0, 0, canvas.width, canvas.height, 'white')
        createText('YOU WIN!', 400, 300, '40px', 'Arial', 'black')
        createText('Press E to Restart', 400, 400, '20px', 'Arial', 'black');
        character1.xPos = 10
        character1.yPos = 540;
        return;
    }*/
    
    //draws deeath screen
    if (character1.dead) {
        createRect(0, 0, canvas.width, canvas.height, 'red')
        createText('YOU DIED...', 300, 200, '40px', 'Arial', 'white')
        createText('press f to pay respects', 300, 300, '20px', 'Arial', 'white')
        
        character1.reset(levels[currentLevel-1].character.x, levels[currentLevel-1].character.y)
        
        for (let i = 0; i < enemies.length; i ++) {
            enemies[i].reset()
        }
        
        for (let i = 0; i < turrets.length; i ++) {
            turrets[i].reset();
        }
        
        return;
    }
    
    // this draws the bottom thing
    createRect(0, 550, canvas.width, 50, 'black');
    
    // this draws the character
    character1.drawCharacter()
    
    //draws healthbar
    character1.healthBar() 
    
    //this draws platforms
    for(i = 0; i < platforms.length; i++){
        platforms[i].drawPlatform()
    }
    
    //this draws enemies
    for(i = 0; i < enemies.length; i++){
        enemies[i].drawEnemy()
    }
    
    //this draws spikes
    for(i = 0; i < spikes.length; i++){
        spikes[i].drawSpikes()
    }
    
    //this draws turrets
    for(i = 0; i < turrets.length; i++){
        spikes[i].drawTurret()
    }
    
    //this draws the exit
    createRect(exit.x, exit.y, exit.width, exit.height, exit.color)
    createText('EXIT', exit.x + 7.5, exit.y + 30, '15px', 'Arial', 'white');
    //loading next level
    if (character1.xPos > exit.x && character1.xPos < exit.x + exit.width && character1.yPos < exit.y + exit.height && character1.yPos > exit.y) {
        clearInterval(interval)
        loadLevel(levels[currentLevel])
    }
}
    
function updateLevel(){

    if (showingWinScreen) {
        return;
    }
    if (character1.dead) {
        return;
    }
    
    character1.shoot()
    
    // character1 gravity
    character1.yVel += gravity;
    character1.yPos += character1.yVel/frameRate
    character1.xPos += character1.xVel/frameRate
    // this is the bottom thing
    if(character1.yPos > 540)
        {
            character1.yPos = 540
            character1.jumps = 0;
            character1.jumping = false
            character1.yVel = -character1.yVel*0.2;//bounciness
            
            if(character1.xVel != 50 && character1.xVel != -50){
                character1.xVel *= 0.9 //friction
            }
        }
    
    character1.shootBullets()
    
    // preventing character1 from going off the screen.
    if (character1.xPos < 0) {
        character1.xPos = 0;
    } else if (character1.xPos > canvas.width) {
        character1.xPos = canvas.width;
    }
    
    for (let i = 0; i < platforms.length; i ++) {
        platforms[i].collision();
    }
    for (let i = 0; i < enemies.length; i ++) {
        enemies[i].shootBullets();
    }
    for (let i = 0; i < enemies.length; i ++) {
        enemies[i].healthBar();
    }
    for (let i = 0; i < turrets.length; i ++) {
        turrets[i].shootBullets();
    }
    
    for (let i = 0; i < spikes.length; i ++) {
        spikes[i].collision();
    }
}
    
function enemyAndTurretAILevel (enemies, turrets) {
        for (let i = 0; i < enemies.length; i ++) {
            enemies[i].enemyAI()
        }
    
        for (let i = 0; i < turrets.length; i ++) {
            turrets[i].turretAI();
        }
}



function drawMenu() {
    if (showingMenu) {
        createRect(0, 0, canvas.width, canvas.height, 'black')
        createText('Press C to Start', 200, 150, "50px", "Arial", 'white')
        createText('Press Q to Shoot', 265, 300, "30px", "Arial", 'white')
    }
}
    
    

    window.onload = () => {
        canvas = document.getElementById("gameCanvas"); 
        canvasContext = canvas.getContext('2d');
        
        drawMenu()
        
        enemyShootingInterval = setInterval(() => {enemyAndTurretAILevel(enemies, turrets)}, 1000)
        
        document.addEventListener('keydown', keydown)
        document.addEventListener('keyup', keyup)
    }
    
    
    
function keydown (evt){
    moveRight(evt, "down")
    moveLeft(evt,"down")
    jump(evt)
}
    
function moveRight (evt, dir) {
    if (evt.code == 'KeyD' && dir == "down") {
        character1.xVel = 50;//pixels/s
        character1.dir = "right"
    }else if(evt.code == 'KeyD' && dir == "up"){
        character1.xVel = 49;
    }
}
function moveLeft(evt,dir) {
    if (evt.code ==  'KeyA' && dir == "down") {
        character1.xVel = -50; //pixels/s
        character1.dir = "left"
    }else if(evt.code == 'KeyA' && dir == "up"){
        character1.xVel = -49;
    }
}

function jump (evt) {
    if (evt.code == 'Space' && character1.jumping == false/* && character1.jumps < 3*/) {
        character1.jumping = true;
        //character1.jumps ++
        character1.yVel -= 200; //pixels per second
    }
}
    
function shoot (evt){
    if (evt.code == 'KeyQ' && character1.shooting == false) {
        character1.shooting = true;
        setTimeout(() => {character1.shooting = false;},100)
    }
}
function getRidOfMenu (evt) {
    if (evt.code == 'KeyC' && showingMenu == true) {
        showingMenu = false;
        loadLevel(levels[0])
    }
}
function dismissWin (evt) {
    if (evt.keyCode === 69) {
        showingWinScreen = false;
    }
}
function revive (evt) {
    if (evt.keyCode === 70) {
        character1.dead = false;
    }
}
function dismissLevelLoading (evt) {
    if (evt.keyCode === 69 && hideDismiss == false) {
        hideDismiss = true;
        interval = setInterval(function () {drawLevel();updateLevel();},frameRate)
    }
}
function keyup(evt){
    shoot(evt)
    moveRight(evt, "up")
    moveLeft(evt,"up")
    getRidOfMenu(evt);
    dismissWin(evt);
    revive(evt);
    dismissLevelLoading(evt);
}
    
function createLevelDismiss (level, playerStartX, playerStartY) {
    character1.reset(playerStartX, playerStartY)
    createRect(0, 0, canvas.width, canvas.height, 'white')
    createText(level, 400, 300, '50px', 'Arial', 'black')
    createText('Press E to Begin', 400, 400, '25px', 'Arial', 'Black')
}
    
function createRect(x, y, width, height, color) {
    canvasContext.fillStyle = color;
    canvasContext.fillRect(x, y, width, height);
}
function createPlatform (x, y, width, height, color) {
    canvasContext.fillStyle = color;
    canvasContext.strokeRect(x, y, width, height);
}
function createText(string, x, y, fontSize, fontType, color) {
    canvasContext.fillStyle = color;
    canvasContext.font = fontSize + " " + fontType;
    canvasContext.fillText(string, x, y);
}
function createEllipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, color) {
    canvasContext.fillStyle = color;
    canvasContext.beginPath();
    canvasContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);
    canvasContext.fill();
}
function createCircle (centerX, centerY, radius, color) {
        canvasContext.fillStyle = color;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, Math.PI*2, true);
        canvasContext.fill();
}
function createTriangle (startX, startY, line1X, line1Y, line2X, line2Y, color) {
        canvasContext.fillStyle = color
        canvasContext.beginPath();
        canvasContext.moveTo(startX, startY)
        canvasContext.lineTo(line1X, line1Y)
        canvasContext.lineTo(line2X, line2Y)
        canvasContext.fill()
}
</script>
</html>
